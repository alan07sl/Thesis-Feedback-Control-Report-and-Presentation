\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Reactive programming is a paradigm in which the program observes events that occur in its environment and reacts to these events as they occur. This is in contrast to the more familiar interactive program flow in which a program \emph{requests} some form of data and only continues the program flow once this data is received. Instead of pulling data in the usual interactive way, reactive programs get data (or events) pushed to them on which they respond according to what is specified. Some of the most common usages of reactive programming can be found in the components of user interfaces (mouse moves, key events or button presses), network communication, results of database queries and clocks or timers. \cite{meijer2012-YMIAD}

In an interactive program, the \textit{consumer} is in charge of requesting the data. The \textit{producer} only has to obey the commands from the consumer and return the requested data. In reactive programs this is the complete opposite: the producer is in charge and sends the data \emph{at its own pace} \cite{berry1991-Reactive}, whereas the consumer has to react to the data it receives from the producer.

This shift in roles between producer and consumer poses an interesting problem: ``\textit{What happens when the consumer cannot keep up with the amount of data that is sent by the producer?}''. In other words, when a consumer has to deal with an overproducing source, how can it handle the excessive amount of data? Several solutions with different policies have already been proposed and implemented in order to solve this problem. We will find that some of these work well under certain circumstances but are not suitable for other kinds of reactive programs. Other solutions change the contract of reactive programming and put the consumer back into command, but still call it `reactive'.

This poses the question whether the concepts behind reactive programming have been generalized too much and whether distinctions between different kinds of reactive programs can lead to a clearer view of what solution works best under which conditions. This thesis will discuss this topic extensively in \autoref{chap:problem-statement} and \autoref{chap:exploring-the-problem-space}.

Based on the conclusions of this first part, we will propose a new solution to the overproduction problem, which makes use of control theory and feedback control systems. This solution can be used as a replacement to solutions that put the consumer back in charge.

Feedback control is a technique that is mainly used in mechanical and electrical engineering, but that is generally overlooked in computer science. One can apply feedback control by continuously measuring a certain property of a system, comparing that to a desired value and alter the system's input based on the error between the desired and measured values. The goal is to ultimately bring the measured property as close to the desired value as possible and keep it as close as possible despite external changes that try to bring the system out of balance. \todo{cite Janert} Practical examples from several fields of engineering are climate control systems, the engine in washing machines, the cruise control system in a car and the reaction control system on a rocket.

Although well suited in several use cases, control theory and the use of feedback systems is generally overlooked in this computer science and software engineering. To the best of our knowledge, there are even no well-written libraries that allow software developers to construct and run feedback systems in a clean way. As we will use feedback control in our solution for the overproduction problem, we will first study the composition of feedback systems and present an small library for this purpose that is based on the concepts of functional and reactive programming. Using this library, we will then propose our solution to the overproduction problem.

\section*{Research Questions}
\addcontentsline{toc}{section}{Research Questions}
\todo{some words}

\subsubsection*{In which ways can a reactive program be controlled in order to prevent overproduction?}
\todo{some words}

\subsubsection*{How can we implement a \emph{reactive} feedback system that is composed from smaller parts?} 
\todo{some words}

\subsubsection*{How can the overproduction problem be reduced to a feedback control system?}
\todo{some words}

\subsubsection*{Can our solution be integrated in an existing API for reactive programming?}
\todo{some words}

\section*{Outline}
\addcontentsline{toc}{section}{Outline}
\todo{some words}
