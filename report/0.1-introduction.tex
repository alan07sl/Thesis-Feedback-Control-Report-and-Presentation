\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Reactive programming is a paradigm in which the program observes events that occur in its environment and reacts to these events as they occur. This is in contrast to the more familiar interactive program flow in which a program \emph{requests} some form of data and only continues the program flow once this data is received. Instead of pulling data in the usual interactive way, reactive programs get data (or events) pushed to them on which they respond according to the program. Some of the most common usages of reactive programming can be found in user interfaces (mouse moves, key events or button presses), network communication, database queries and clocks or timers \cite{meijer2012-YMIAD}.

In an interactive program, the \textit{consumer} is in charge of requesting the data. The \textit{producer} only has to obey the commands from the consumer and return the requested data. In reactive programs this is the exact opposite: the producer is in charge and sends the data \emph{at its own pace} \cite{berry1991-Reactive}, whereas the consumer has to react to the data it receives from the producer.

This shift in roles between producer and consumer poses an interesting problem: ``\textit{What happens when the consumer cannot keep up with the amount of data that is sent by the producer?}''. In other words, when a consumer has to deal with an overproducing source, how can it handle the excessive amount of data? Several solutions with different policies have already been proposed and implemented in order to solve this problem \cite{RxJava-Wiki-Callstack-Blocking,RxJava-Wiki-Backpressure,Reactive-Streams}. We find, however, that some of these work well under certain circumstances but are not suitable for all kinds of reactive programs in general. Other solutions change the contract of reactive programming and put the consumer back into command, but, surprisingly, still call it `reactive'.

This poses the question whether the concepts behind reactive programming have been generalized too much and whether distinctions between different kinds of reactive programs can lead to a clearer view of what solution works best under which conditions. This thesis will discuss this topic extensively in \Cref{chap:problem-statement} and \Cref{chap:exploring-the-problem-space}.

Based on the conclusions of this first part, we will propose a new solution to the overproduction problem, which makes use of control theory and feedback control systems. This solution can be used as a replacement to solutions that put the consumer back in charge.

Feedback control is a technique that is mainly used in mechanical and electrical engineering, but is generally overlooked in computer science. Feedback control can be applied by continuously measuring a system's property, comparing it to a desired value and alter the system's input based on the error between the desired and measured values. The goal is to ultimately bring the measured property as close to the desired value as possible and keep it this way despite external changes that try to bring the system out of balance \cite{janert2013-feedback}.

Although well suited in several use cases, control theory is generally overlooked in computer science and software engineering. To the best of our knowledge, there are even no well-written libraries that allow software developers to construct and run feedback systems in a clean way. As we will use feedback control in our solution for the overproduction problem, we will study the composition of feedback systems in \Cref{chap:intro-to-feedback-control} and present an concise but powerful library for this purpose that is based on the concepts of functional and reactive programming (\Cref{chap:feedback-api}). Using this library, we will then propose our solution to the overproduction problem.

\section*{Research Questions}
\addcontentsline{toc}{section}{Research Questions}
This thesis answers a number of questions that are related to reactive programming, overproducing sources in a reactive context and feedback control, which are listed and briefly introduced in this section.

\subsubsection*{In what ways can a reactive program already be controlled to prevent overproduction?}
There are multiple solutions for controlling overproduction in the context of reactive programming. To understand these solutions we first need to identify the various types of reactive programs and consider their mutual similarities and differences. This is important since the existing solutions do not work for every type of reactive program.

\subsubsection*{How can we implement a \emph{reactive} feedback system that is composed of smaller parts?} 
As the solution to overproduction that is presented in this thesis makes use of control theory and feedback control, and given that these are not yet widely known or used in computer science, it is important to develop an understanding of these techniques and create the tools necessary to construct feedback systems in an easy way. We will show that these can be seen as reactive programs and implement a library on top of existing reactive programming API's.

\subsubsection*{How can the overproduction problem be reduced to a feedback control problem?}
To solve overproduction using feedback control, it is necessary to get out of the context of reactive programming and abstract this into more general problems that can be solved by control theory. Once we develop and solve this more general problem, we can put it back into the context of reactive programs.

\subsubsection*{Can this new solution to overproduction be integrated in an existing API for reactive programming?}
In order for this solution to be useful in practice it is important to be able to interface with existing API's for reactive programming. To test this, a clean API is needed that does not yet implement any solutions for overproduction. For this purpose we use the newly created RxMobile API \cite{RxMobile}.

\section*{Outline}
\addcontentsline{toc}{section}{Outline}
In the next chapter we will continue this thesis report with a short discussion on the definitions of interactive and reactive programming as it is defined in literature (\Cref{chap:problem-statement}). This is followed up with an extensive introduction to a widely used reactive programming API whose concepts have been implemented in many languages. We will discuss the basic principles of this API as well as it's derivation from and relationships with interactive programming interfaces. Once these foundations are laid out, we will give an overview of the different ways in which it tries to overcome overproduction problems. It is important to first gain a good understanding of reactive programming in general and this API especially, since we will build on top of these in the rest of this thesis.

Different circumstances require different approaches to overproduction, as we already hypothesized above. In \Cref{chap:exploring-the-problem-space} we will explore and categorize these circumstances and describe how overproduction is currently best dealt with in each of these situations. Here we also discuss the current state of abstraction over reactive programming and describe our solution to overproduction and explain for which type of reactive programs we think this will apply.

As we will use control theory to solve the problem of overproduction, and given that this topic is not well known in computer science we will briefly introduce this topic in \Cref{chap:intro-to-feedback-control}. We also provide an extended example of a simple way to apply feedback control. This example is further used to briefly demonstrate some of the difficulties we currently experience with setting up and tuning a feedback control system.

To the best of our knowledge there does not exist a proper API, library or framework for building and running feedback control systems in production level systems. In \Cref{chap:feedback-api} we derive a simple API for such feedback control systems. This API is based on the concepts of functional and reactive programming and has its basis in the solid foundations of theoretical computer science and category theory. Near the end of this chapter we will return to the example from \Cref{chap:intro-to-feedback-control} and refactor this application such that it uses our newly designed API.

\Cref{chap:solving-overproduction} combines the discussion about overproduction and the theory of feedback control and proposes a new way to deal with overproduction. In this chapter we will reduce this problem to where it can be controlled in an easier way, discuss the various aspects of the resulting feedback system and integrate it in such a way that it can be used as part of a reactive API like RxJava or RxMobile.
