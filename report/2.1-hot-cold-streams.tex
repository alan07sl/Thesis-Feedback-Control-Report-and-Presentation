\section{Hot and cold streams}
Applying the definition of reactiveness by Berry \cite{berry1989-Reactive} to the Rx \obs, we can conclude that every \obs sequence starts with a source that emits values at its own pace. No matter which function is used for this (\code{apply}, \code{range}, \code{timer}, \code{interval}, etc.), ultimately they all are the result of the \code{Observable.create} function. This function lifts an arbitrary source into the \obs interface and treats its values like streaming data. The behavior that is exposed by the resulting stream can, however, differ from source to source. We already introduced a behavioral distinction in \Cref{subsec:stream-kinds}, where we separated hot and cold streams. In this section we will further analyze this distinction and connect it with the definition of reactiveness. 

Sources like clocks, stock tickers, mouse moves or key presses start emitting regardless of any \obv being subscribed to the stream. When no one listens, the data is simply discarded; when multiple \obv instances are subscribed, every one of them receives the same data at (approximately) the same time. In case an \obv subscribes at a later time, it will not receive all previously emitted data, but will only share in the data that is send after it is subscribed. This kind of source is considered to be \textit{hot}. It is strictly reactive, meaning that it can only emit data at a speed which is determined by the source and has no way to be slowed down by any \obv that cannot cope with the amount of data sent.

On the other hand there are streams that originate from sources that are actually interactive. These include the results of database queries and \ieb sequences. Often the reason for them being wrapped into an \obs is because of a potential delay that needs to be awaited before the result is returned without blocking the program flow or call stack, or simply because the context of the program requires an \obs rather than an \ieb. Regarding the former, it may (for example in case of lazy evaluation) take some time before the \ier has produced its next element. The \obs will however not start emitting its data immediately, like the hot variant, but will wait until at least one \obv is subscribed. Only then it will start producing its values. In case a second \obv subscribes, the stream will effectively duplicate itself and start all over again with emitting the first values. Unless specified by operator sequences, this means that the lazy \ier in the source will have to produce its values a second time as well. In the end, both the first and second \obv have received the same set of data, even though the second subscribed much later than the first. A stream with this kind of behavior is referred to as a \textit{cold} \obs.

We propose a further behavioral distinction in the class of cold streams: the \textit{cold asynchronous \obs} and the \textit{cold synchronous \obs}. The former is bound by a certain notion of time. This type wraps a source that is interactive, but can take some time before it produces its next element. Examples of this can be a network response, the result of a database query or an \ieb sequence where each element is computed lazily and therefore takes some amount of time to be returned. Often an \obs like this is executed on a different thread using \code{observeOn} or \code{subscribeOn}, in order to avoid blocking the programs main thread.

The \textit{cold synchronous \obs}, on the other hand, is \emph{not} bound by any notion of time. This kind of stream mainly wraps interactive sources for which the values have already been computed, such as a list, and will fire it's values as fast as the downstream will allow it.
