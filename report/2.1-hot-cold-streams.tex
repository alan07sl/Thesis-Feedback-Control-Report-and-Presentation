\section{Hot and cold streams}
Applying the definition of reactiveness by Benveniste and Berry\cite{berry1991-Reactive} to the Rx \obs, we can conclude that every \obs sequence starts with a source that emits values at its own pace. No matter which function is used for this, ultimately they all are the result of the \code{Observable.create} function. This function lifts an arbitrary source in the \obs interface and treats its values like streaming data. The behavior that is exposed by the resulting stream can however differ from source to source.

Sources like clocks, mouse moves or key presses start emitting whenever it desires, regardless of any \obv being subscribed to the stream. When no one is listening, the data is simply discarded; when multiple \obv are subscribed, every one of them receives the same data at (approximately) the same time. In case an \obv subscribes on a later moment, it will not receive all previously emitted data, but will only share in the data that is send after it is subscribed. This kind of source is referred to as a \textit{hot} stream. It is strictly reactive, meaning that it can only emit data at a speed which is determined by the environment and has no way to be slowed down by any \obv that cannot cope with the amount of data sent.

On the other hand there are streams that originate from sources that are actually interactive. These include the results of database queries and \ieb sequences. Often the reason for them being wrapped into an \obs is because of a potential delay that needs to be awaited before the result is returned, without blocking the program flow or call stack. It may, for example in case of lazy evaluation, take some time before the \ier has produced its next element. The \obs will however not start emitting its data immediately, like the hot variant, but will wait until at least one \obv is subscribed. Only then it will start producing its values. In case a second \obv subscribes, the stream will effectively duplicate itself and start all over again with emitting the first values. Unless specified by operator sequences, this means that the lazy \ier in the source will have to produce its values a second time as well. In the end, both the first and second \obv have received the same set of data, even though the second subscribed much later than the first. A stream with this kind of behavior is referred to as a \textit{cold} \obs.

In the rest of this thesis we will distinguish between two types of the cold \obs. First there is the \textit{cold with-latency \obs}, which is bound by a certain notion of time. This type wraps a source that is interactive, but can take some time before it produces its next element. Examples of this can be a network response, the result of a database query or an \ieb sequence where each element is computed lazily and takes some time to be returned. On the other hand we distinguish the \textit{cold no-latency \obs}, which is \emph{not} bound to any notion of time. This type mainly wraps interactive sources for which the values are already computed, such as a list.

In short, a hot \obs has a source that is strictly reactive, whereas a cold \obs originates from a source that is interactive. With the latter, an \obv could potentially ask the \obs to slow down by generating elements less frequently, even though this would strictly speaking be against the definition of reactiveness. The \obs would not have to buffer unbounded amounts of elements that cannot be consumed immediately, it will just generate its elements in a slower pace.

This is however not possible for a hot \obs, since it reacts to events from the outside environment. It is not possible for an \obv to ask the source to slow down the movement of the mouse, nor is it possible for the \obv to request less frequent key presses or clock ticks. These events are dependent on time; their speed and frequency is determined by the environment \cite{berry1991-Reactive} and they cannot be regulated in other ways than the ones described in section~\ref{subsec:avoiding-overproduction}.