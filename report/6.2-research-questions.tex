\section{Research Questions}
In this report we answer three research questions, which will be summarized in this section.

\subsection*{In which way can a reactive program already be controlled to prevent overproduction?}
The classification of sources, as described above, brings an important distinction with it: not all currently existing ways of preventing overflow in a stream are suitable for each type of source.

A primitive solution that works for all three types of sources is \textit{buffering}. Here all data that cannot be processed immediately is put in a buffer, such that the consumer can process it at a later time. This solution only works fine for a `bursty' source, which emits a lot of data at once, followed by a period in which it produces sufficiently less data for the consumer to fully catch up and clear the buffer, before another burst of data comes in. If the behavior of the source is, however, persistent in sending too much data, a buffering solution will not suffice, since the buffer will then grow unboundedly and sooner or later cause the program to run out of memory.

The only solutions that work for a \textit{hot source} are either discarding the data that cannot be processed immediately or grouping it into larger sections and processing it in these groups.

These solutions do also work for the \textit{cold asynchronous sources}, as they are also bound by a certain notion of time. Besides that, the backpressure technique as proposed by Reactive Streams works for these sources as well. This is due to the fact that these sources allow for the consumer to manage the rate at which the producer is allowed to emit its data.

Backpressure also works fine on \textit{cold synchronous sources}, although the best way to control their emission rates is already incorporated at runtime level: callstack blocking. Due to the nature of these streams, the next element can only be emitted once the current element is fully processed. Note that this technique is also naturally used in \textit{hot} and \textit{cold asynchronous sources}, but that this can potentially lead to out-of-memory errors.

\subsection*{How can we implement a \textit{reactive} feedback system that is composed of smaller parts?}
A feedback system consists of a number of transformations (or components) that are being composed and where the output of the last transformation is not only the feedback system's output, but is also used as part of the input of the first transformation. The other part of this input is the setpoint, which is combined with the output in any arbitrary way, which serves as the complete input for the first transformation. From this point of view, the whole feedback system is just another component that happens to be constructed out of other, more primative, component. Therefore, the feedback system can potentially be used itself as a component in another feedback system.

We derived an API for such components that builds on top of the RxJava library. We also introduced operators for composing these components in both a sequential and parallel way and related these to the well known structure of \textit{Arrow}s. Finally we introduced a set of operators that makes it possible to turn a sequence of components into a feedback system by feeding back the sequence's output stream to its input stream. The resulting API offers a concise way of describing a feedback system in just a couple of lines of code.

\subsection*{How can the overproduction problem be reduced to a feedback control problem?}
We proposed a new solution to the overproduction problem that uses feedback control at its core. While Reactive Stream's backpressure implementation in RxJava moves the overflow control up to a certain operator that can be anywhere in the operator sequence, we chose to move it up to the point where the source is drained into the operator sequence. There we chose to place a buffer and control the number of elements that are being requested from the source. This is done by measuring the \textit{throughput} of the buffer, which is equal to the ratio between how many elements are being pulled out from the buffer and the number of element that were in the buffer during a particular time frame.

With this we have reduced the problem of overproduction to a problem of controlling the size of a buffer. Here the metric (or control output) is the \textit{throughput}, which we bound to be a number between 0.0 and 1.0 (boundaries inclusive). Since the ideal value for the throughput is 1.0 (meaning that all data is consumed directly), we set this as the setpoint of the feedback system that controls the buffer. Using a custom, incremental controller, we transform the tracking error into a new number of elements to be requested from the source.
