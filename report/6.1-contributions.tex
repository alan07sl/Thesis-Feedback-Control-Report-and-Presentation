\section{Contributions}
We propose a classification of various sources that can be wrapped in an \obs. This classification is based on the behavior of a stream when it is subscribed to by zero, one or multiple \code{Observer}s. A cold stream is known for not doing anything when it has zero subscribers and emitting all elements, right from the start, when it is subscribed to by multiple subscribers. A hot stream, on the other hand, emits its elements whenever they occur. If no subscriber is listening, the data is simply discarded, whereas multiple subscribers that are listening simultaneously receive the same data at (approximately) the same time.

We propose to classify the source of these hot and cold streams in a similar way. A hot stream can only originate from a purely reactive source: it can, following the definition by Benveniste and Berry, not be interacted with and will emit data at its own pace. A classic example of this is a stream of mouse moves, where the consumer is not able to regulate the amount of data that is been sent, because it is not able to communicate with the stream's source. A cold stream, on the other hand, can only originate from a source that can actually be interacted with. In this source, the consumer can determine the speed at which the data is emitted and is thus able to control the source in such a way that it will not produce too much data for the consumer to handle. We further distinguish two types of cold sources: the cold asynchronous source, which after it has received a request for more data might take a while to emit this data and therefore is dependent on a certain notion of time, whereas the cold synchronous source will emit the requested amount of data immediately. An example of the latter source is a list that is already in memory; an example of the former is a SQL query, which may take some time to compute its next record.

A second contribution of this research is an API for constructing and executing feedback control systems that can be used in production level systems. To the best of our knowledge, there are no such libraries yet. The overall problem with feedback control theory is that it is mainly described in terms of mathematical transformations. This is also the case in university classes for computer scientists (if the subject is taught at all). However, these mathematical transformations are currently unknown in the field of computer science and the situations in which we wish to use feedback control. Our API, instead, considers the transformations of which a feedback system consists to be transformations between streams of data that can be composed in several ways and using various operators. We think our API will provide a great tool in designing and executing feedback systems without first having to complete a degree in higher-order mathematics.

Using this new API for feedback control, we are now able to come up with a new solution for preventing overproduction. Since we concluded that the only way in which we can control hot sources is to either buffer or drop data, we mainly focused our solution on cold streams, in which we are able to interact with the source. While other solutions like Reactive Streams and RxJava's reactive pull recursively control for overproduction in every single operator, we propose to only consider overproduction to be a problem at the point at which the source drains its data into the stream. The rationale is that if we control the source's speed at which it drains data into the stream, we do not have the problem of overproduction in the remainder of the stream.

In order to do so, we have created a feedback system around the source, that requests a certain amount of data, which is drained into a buffer. The actual stream, including the operators and consumer, polls data from this buffer for further processing. Based on how much data comes in and goes out of the buffer during a certain interval, the feedback system can then decide to request fewer or more data for the next interval. Given this approach we regulate the flow of data such that the consumer is able to handle every bit of data appropriately.

This solution of controlling the source's speed results in the observation that now it is no longer needed to have any form of flow regulation in every single operator, as is currently the case in RxJava. Given our contribution, the operator implementations no longer requires such things and can have the single responsibility of reactively transforming the data according to the operator's nature.
