\section{An extended example}
To get a better feel for how a feedback control system works in practice, we will discuss a simple but interesting application of feedback control that uses the theory covered in the previous sections. In this section we show an imperative reference implementation. In the next chapter we will continue to use and refactor this application as we come up with an API for constructing and executing feedback systems. The application at hand is a port from the original implementation by Nikita Leshenko in Javascript, CSS and HTML \cite{nikital-balltracker}. We will however use Scala as our programming language and JavaFx for drawing the graphics on the screen.

The application consists of a flat surface on which a ball can move around. The goal is to move the ball from its initial position to the position on the surface that the user clicks on with the mouse. \autoref{fig:balltracker-initial} shows the ball in its initial state when the application starts. When the user clicks on the screen, the ball starts moving to that position as shown by \autoref{fig:balltracker-moving}. Besides the background and the ball, also the desired position, a dashed line between the ball and the desired position, the acceleration in both the $x$ and $y$ directions and a trail of previous positions are drawn (which are fading away over time). After some time the ball is at its desired position and waits there for a new position to navigate to (\autoref{fig:balltracker-reached}). Notice that the desired position can also be updated while the ball is still moving, in which case it moves to the new and discards the old destination.

In order to allow the ball to move in a natural way, we remind the reader of some basic equations from physics that describe the one dimensional motion of an object as a function of time (\autoref{eq:motion}). Here $x_t$, $v_t$ and $a_t$ are the ball's position, velocity and acceleration at time $t$ respectively. For two-dimensional motion we can combine two sets of these equations for both dimensions.

\begin{subequations}
	\begin{equation}
		x_t = x_{t - 1} + v_t \cdot \Delta t
	\end{equation}
	\begin{equation}
		v_t = v_{t - 1} + a_t \cdot \Delta t
	\end{equation}
	\label{eq:motion}
\end{subequations}

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.80\linewidth}
		\includegraphics[trim = 0mm 110mm 0mm 0mm, clip, width=\linewidth]{figures/BallTracker-initial.png}
		\caption{Initial}
		\label{fig:balltracker-initial}
	\end{subfigure}
	
	\begin{subfigure}[b]{0.80\linewidth}
		\includegraphics[trim = 0mm 110mm 0mm 0mm, clip, width=\linewidth]{figures/BallTracker-moving.png}
		\caption{Moving to desired position}
		\label{fig:balltracker-moving}
	\end{subfigure}
	
	\begin{subfigure}[b]{0.80\linewidth}
		\includegraphics[trim = 0mm 110mm 0mm 0mm, clip, width=\linewidth]{figures/BallTracker-overshooting.png}
		\caption{Moving to desired position}
		\label{fig:balltracker-moving}
	\end{subfigure}
	
	\begin{subfigure}[b]{0.80\linewidth}
		\includegraphics[trim = 0mm 110mm 0mm 0mm, clip, width=\linewidth]{figures/BallTracker-desired.png}
		\caption{Reached desired position}
		\label{fig:balltracker-reached}
	\end{subfigure}
	\caption{Ball tracker}
	\label{fig:balltracker}
\end{figure}

The implementation of these required pieces of physics can be found in \autoref{lst:ball-physics}. We first define a \code{Position}, \code{Velocity} and \code{Acceleration} as tuples of \code{Double} as well as some mathematical operations on the tuple type. The \code{Ball} class describes the state of the ball having a position, velocity and acceleration. A second constructor (\code{apply}) defines the initial position with no acceleration or velocity. The method \code{accelerate} on this class takes a new acceleration and calculates a new state for the ball according to \autoref{eq:motion}. Notice that we discard the $\Delta t$ term as this is always equal to 1. To keep track of the ball's previous positions we define a type \code{History}, being a queue of \code{Position}s.

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=ScalaStyle, caption={Ball motion physics}, label={lst:ball-physics}]
type Position $=$ (Double, Double)
type Velocity $=$ (Double, Double)
type Acceleration $=$ (Double, Double)
type History $=$ mutable.Queue[Position]

implicit class Tuple2Math[X: Numeric, Y: Numeric](val src: (X, Y)) {
  import Numeric.Implicits._
  def +(other: (X, Y)) $=$ (src._1 + other._1, src._2 + other._2)
  def -(other: (X, Y)) $=$ (src._1 - other._1, src._2 - other._2)
  def *[Z](scalar: Double) $=$ (src._1.toDouble * scalar, src._2.toDouble * scalar)
  def map[Z](f: X $\Rightarrow$ Z)(implicit ev: Y $=:=$ X): (Z, Z) $=$
    ((x: X, y: Y) $\Rightarrow$ (f(x), f.compose(ev)(y))).tupled(src)
}

case class Ball(acc: Acceleration, vel: Velocity, pos: Position) {
  def accelerate(newAcc: Acceleration): Ball $=$ {
    Ball(newAcc, vel + newAcc, pos + vel + newAcc)
  }
}
object Ball {
  def apply(radius: Double): Ball $=$ {
    Ball((0.0, 0.0), (0.0, 0.0), (radius, radius))
  }
}
\end{lstlisting}
\end{minipage}

\todo{text here}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=ScalaStyle, caption={Ball drawing}, label={lst:ball-feedback}]
var ball $=$ Ball(ballRadius)

var setpoint $=$ ball.position
var prevError $=$ (0.0, 0.0)
var integral $=$ (0.0, 0.0)

val history $=$ new History
var historyTick $=$ 0

def pid: Acceleration $=$ {
  val kp $=$ 3.0
  val ki $=$ 0.0001
  val kd $=$ 80.0

  val error $=$ setpoint - ball.position
  val derivative $=$ error - prevError

  integral $=$ integral + error
  prevError $=$ error

  (error * kp + integral * ki + derivative * kd) * 0.001
}

def update(implicit gc: GraphicsContext): Unit $=$ {
  val acceleration $=$ pid map (a $\Rightarrow$ math.max(math.min(a, 0.2), -0.2))
  ball $=$ ball accelerate acceleration

  // managing the history
  historyTick $+=$ 1
  if (historyTick $==$ 5) {
    historyTick $=$ 0

    if (history.size $>=$ 50)
      history.dequeue
    history enqueue ball.position
  }

  // drawing all the elements
  Platform runLater (() $\Rightarrow$ Draw.draw(ball.position, setpoint, ball.acceleration, history))
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=ScalaStyle, caption={Ball drawing}, label={lst:ball-drawing}]
class BallTracker extends Application {

  // code from Listing 3.2

  def start(stage: Stage) $=$ {
    val canvas $=$ new Canvas(width, height)
    implicit val gc $=$ canvas getGraphicsContext2D

    val root $=$ new StackPane(canvas)
    root setAlignment Pos.TOP_LEFT
    root.addEventHandler(MouseEvent.MOUSE_CLICKED,
        (e: MouseEvent) $\Rightarrow$ setpoint $=$ (e.getX, e.getY))

    val loop $=$ new Thread(() $\Rightarrow$ while (true) { update; Thread.sleep(16) })

    stage setOnHidden ((_: WindowEvent) $\Rightarrow$ System.exit(0))
    val scene $=$ new Scene(root, width, height)
    stage setScene scene
    stage setTitle "Balltracker"
    stage.show()

    loop.start()
  }
}
object BallTracker extends App {
  Application.launch(classOf[BallTracker])
}
\end{lstlisting}
\end{minipage}
