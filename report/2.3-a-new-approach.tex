\section{A new approach}
As pointed out by the RxJava wiki \cite{RxJava-Wiki-Backpressure}, backpressure does not make the problem of an overproducing source go away. It only moves the problem up the chain of operators to a point where it can be handled better. This means that a \code{request(n)} call from the \code{zip} operator in section~\ref{sec:fastproc-slowcons} goes up the chain to the point where it can fulfill that request. This is either an operator or the source that is wrapped in an \code{Observable.create} or one of its higher abstractions.

The main problem for this to be working correctly is that now all operators that have to support backpressure also have to change their implementation. In some cases (like \code{take(n)} or \code{skip(n)}) this can be a simple straightforward refactoring or an extra method override. However, in other cases it is much more complicated to do this. Since the \obs is a monad, it has to implement \code{flatMap}, which in the world of streams means mapping and merging. But how can one implement this \code{merge} operator in terms of requests? When \code{n} elements are requested, to which of the \code{m} upstream \obs sequences is this request sent? Is it sent to only \emph{one} of these, with the possibility that this is a rather slow producer; or is the \code{request(n)} split into multiple smaller \code{request(k)}s and sent to multiple upstreams with the possibility of getting less than \code{n} results; or is the \code{request(n)} sent to all upstreams with the possibility of getting much more than \code{n} elements? All of a sudden the implementation is no longer straightforward and easy, as we would like it to be, but becomes much more complicated by making decisions like this. RxJava chose an approach with round-robin techniques to implement \code{merge}. This however caused a giant increase in code complexity \cite{RxJava-source-code}, making the code almost unreadable and not suitable for any form of maintenance.

The underlying issue of this code complexity is the coupling of this approach with the operators. When the new strategy of backpressure needed to be introduced in the 0.20 version of the RxJava code base, it automatically followed that the operators had to be changed as well. This was mainly caused by change in direction of control, which went from `\textit{the producer is in charge}' to `\textit{the consumer is in charge}'.

The other problem with this is that the backpressure approach only works for cold, interactive, sources and that it cannot be applied to hot, reactive sources like mouse moves or clocks. This has been discussed many times before in this report and is also acknowledged by the RxJava wiki \cite{RxJava-Wiki-HotCold}. It follows from the definition of reactive programs by Benveniste and Berry that reactive sources cannot be controlled in this way. The best method known thus far are the loss-less and lossy operators on streams that were discussed in sections~\ref{subsec:avoiding-overproduction}. As the rest of this report will focus on a new approach to backpressure, we will from now on ignore hot streams and mainly focus on cold, interactive sources.

Moving the problem of overproduction up the operator chain to a point where it can be handled better, like RxJava did, is not a bad idea at all. However, in our opinion RxJava did not go far enough with this approach. We think it is better to decouple the flow control from the operators and move it to the source of the stream. This way we can keep the API clean, we do not have to take this flow control into account while implementing new operators, we do not have to reimplement operators for this and (most importantly) we can keep the operator sequences reactive.

In order to do so, we need to observe where the \obs comes from. In essence, an \obs is nothing more than a source wrapped in \code{Observable.create}, from which it inherits all the operators as well as the possibility to apply backpressure. This wrapped source might then be used as the origin of an \obs sequence or it might be returned by an operator like \code{flatMap}.

Instead of wrapping a cold source in the \code{Observable.create}, we want to wrap it in an interactive interface (such that communication with the source is not coupled with its own specific interface) and pull the data out of the source via this interface. We will then add these values to a bounded buffer, from which they are pulled again by a downstream \obs on another thread. Once an element is pulled from the buffer, it will block the downstream \obs's callstack from pulling another element until the current element is fully processed or taken over by another thread. In the mean time the buffer request new elements from the source and by doing so keeping the downstream \obs as busy as it possibly can.

\todo{add a picture of our approach here}

With this approach we have reduced the problem of overproduction to a problem of controlling the size of a buffer to be as small as possible, without the buffer being exhausted by a fast consuming downstream. A buffer size that is too small can lead to a needless delay in consuming the data, whereas a too large buffer size is not desirable as well, given that we want to spend as little resources as possible. The complicating factor here is that it is unknown at all times how long it will take for the source to produce a next element.

To overcome this unknown factor, control the size of the buffer and only request new elements from the source when needed, we will use a well-known technique from mechanical and electrical engineering called \textit{feedback control}. Since this is a technique that is unfortunately not as well-known in computer science and software engineering as it is in other parts of science and engineering, we will introduce this technique in the upcoming chapters and present the rest of our solution to the overproduction problem after that.