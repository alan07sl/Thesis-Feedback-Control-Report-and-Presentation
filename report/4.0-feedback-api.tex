\chapter{An API for feedback control}

While studying the principles of feedback control, we discovered that there are hardly any publicly available libraries or APIs that abstract over the notions of feedback control, allowing us to create and execute feedback systems, both in simulation and in practice. Although surprising at first, this is completely in accordance with the earlier observation that feedback control is not (yet) a commonly used technique in computer science\footnote{Even though we were not able to find existing APIs for this purpose, we would not be surprised if companies turned out to have libraries like this in private.}. Surely, we can write the code ourselves as shown in \cref{sec:imperative-balltracker}, but that isn't really reusable, creates the danger of copy-paste behavior and is more prone to bugs than a dedicated API.

In this chapter we present our own API for creating and executing feedback systems that can potentially be used in production software. \todo{rest of the introduction and layout of this chapter}

\section{Related work}
One of the few libraries we found is described by Janert in his book ``\textit{Feedback Control for Computer Systems}'' \cite{janert2013-feedback}. Janert presents a small framework for simulating feedback loops with the purpose of being a teaching tool that makes it simple and transparent to demonstrate the algorithms presented in several case studies and to encourage experimentation. He explicitly states that little emphasis was placed on elegant implementations or time efficiency and that this framework is not meant to be used in production software. What distinguishes his framework from other simulation frameworks for control systems, however, is way that the components that make up a feedback loop are implemented. As discussed before, most feedback systems in physics and engineering are described in terms of complex mathematics, using transfer functions and Laplace transformations, that operate in the frequency domain. Janert's API, however, allows algorithms to be implemented in the time domain, which is a more natural representation to software developers and people that are not familiar to the mathematics based approach.

One of the central aspects of Janert's framework is the \code{Component} class which contains two methods with the following signatures: \code{def work(u: Double): Double}, which encapsulates the dynamic function of a component, called once every feedback cycle and \code{def monitoring: String}, which is just a convenience function and allows for a uniform approach to logging. All components, controlled systems, controllers and more advanced building blocks like actuators and filters, are just subclasses of this \code{Component} that implement these two methods. The feedback system is then simulated using a loop that iterates over time stamps and which calls the \code{work} method on the next \code{Component} with the result of calling the \code{work} method of the previous \code{Component}. Finally at the end of each loop cycle the result is printed to the console using the \code{monitor} method of the \code{Component} that represents the system under control.

As pointed out earlier, this framework does well for simulation but is not really useful for production software. One concern with this framework is that it performs a feedback cycle with regular intervals between each other. However, one can easily imagine a controlled system which produces a control output very irregularly. In that case the feedback cycle has to respond to the emission of a new data point rather than asking the controlled system for its next input. Another concern related to this is the ability to handle concurrency appropriately. A component in the feedback loop might perform some kind of timing related work that requires running on a different thread or thread pool. Finally we should note that the subclasses of \code{Component} have to use mutable state for mutable state, which is something that computer science has come to terms with as not being so practical in some cases as we once thought it would be. Especially when introducing concurrency, mutable state is something you want to avoid at all cost! \todo{keep these in mind when developing our own API and refer to these concerns there!}




\clearpage
\todo{content here}

\begin{itemize}
	\item Since we do feedback control for computer science, we want to come up with an API to create feedback systems
	\begin{itemize}
		\item A good API does not yet exist
		\item Some simple stuff in Python
		\item Solution from Peti Koch
	\end{itemize}
	\item Introduce the ball tracker as a toy example
	\begin{itemize}
		\item First on 1 dimension; implemented with for-loops etc.
		\item Use this throughout the rest of the Feedback Control section
	\end{itemize}
	\item Feedback control as ‘working with streams’
	\begin{itemize}
		\item A component sits in between 2 streams and performs some sort of transformation
		\item A component is compositional: connecting components, making feedback loop, zipping $\rightarrow$ a feedback system is the same as a component
		\item Observation: \textbf{a component is the same as a Mealy Machine}
		\item Derive the exact type of a component, starting from a Mealy Machine and using category theory
		\item Observation: \textbf{a component is an Arrow}
		\item Introduce the operators on Component
		\begin{itemize}
			\item Arrow operators (see \LaTeX code)
%			\begin{itemize}
%				\item \code{arr :: Arrow a => (b -> c) -> a b c}
%				\item \code{(>>>) :: Arrow a => a b c -> a c d -> a b d}
%				\item \code{first :: Arrow a => a b c -> a (b,d) (c,d)}
%				\item \code{second :: Arrow a => a b c -> a (d,b) (d,c)}
%				\item \code{(***) :: Arrow a => a b c -> a d e -> a (b,d) (c,e)}
%				\item \code{(\&\&\&) :: Arrow a => a b c -> a b d -> a b (c,d)}
%				\item \code{lift2A :: Arrow a => (b -> c -> d) -> a e b ->   a e c -> a e d}
%				\item \code{loop :: Arrow a => a (b,d) (c,d) -> a b c}
%			\end{itemize}
			\item Concat
			\item Zip
			\item Feedback
			\item \textit{$<$many RxMobile operators$>$}
			\item Lift and LiftA2 (as generalizing over all operators)
		\end{itemize}
		\item Ball tracker example with the API
	\end{itemize}
\end{itemize}

\todo{below in chap4 with looking back on chap3?}
The ultimate goal in computer science (especially in software engineering) is to wrap the theory of a piece of technology in some kind of an API, such that anybody can incorperate it easily in their applications, platforms or frameworks. The notion of feedback control is however apparently so foreign to computer science that there does not exist a proper API for this yet. 