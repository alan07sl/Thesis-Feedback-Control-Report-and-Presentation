\todo{potentially start the following section on a new page}

\section{Backpressure}
In the previous section we discussed that a reactive collection is exactly the same as every other collection: it obeys the same rules and the same operators (like \code{map} and \code{filter}) can be defined. One difference however is that a reactive collection is push-based, whereas a interactive collection is pull-based. Rather than the consumer being in charge, asking for the next value, here the producer is in charge and \emph{it} decides when to emit a next value. The consumer just has to listen and can only react to the elements emitted by the producer.

A risk that arises from allowing the producer to be in charge is called `\textit{backpressure}'. \todo{reference to literature or website of reactivex.io} This is a concept originally taken from fluid dynamics (physics) and occurs when the consumer cannot keep up with the rate in which the producer is producing the data. This gives rise to the problem of what to do with the growing accumulation of unconsumed data.

A classic example of backpressure in reactive systems is the \code{zip} operator, which merges two (or more) streams by using a combiner function whenever both streams have produced an element. In this operator backpressure occurs when one \obs produces twice as fast as the other. This is a problem, because \code{zip} cannot keep up with the rate in which the first \obs is producing, since the second \obs is much slower. The most common, but also slightly naive implementation for this operator maintains an ever expending buffer of elements emitted by the first \obs to eventually combine them with the data emitted by the slower stream.

Ever expanding buffers is common solution in dealing with backpressure. A fast emitting \obs is draining its data into a buffer and the much slower \obv eventually takes the data out of the buffer. The major problem with this solution (and thus with the implementation of \code{zip} as described above) is that the buffer will have to use an unwieldy amount of system resources.

\subsection{Avoiding backpressure}
One way of dealing with backpressure is to simply avoiding the problem and take proactive measures whenever backpressure is expected happen. In the following we will discuss several ways to reduce the amount of data by using standard operators that are defined on the \obs interface. For this we distinguish two types of operators: lossy and lossless operators. \todo{reference to https://xgrommx.github.io/rx-book/content/getting\_started\_with\_rxjs/creating\_and\_querying\_observable\_sequences/backpressure.html}

\subsubsection{Lossy operators}
One set of operators avoids backpressure in a lossy way, meaning that some of the emitted data will be dropped.

\paragraph{Throttling} The \code{throttle(interval: Duration)} operator only propagates the first element that is received in a particular interval. All other elements are discarded. Once has finished, a new interval starts immediately, in which again the first received element is propagated and all other elements are discarded.

\paragraph{Sample} Rather than propagating the first element and discarding all others, the \code{sample(interval: Duration)} operator is used to discard all elements except for the last one that is received in a certain \code{interval}. This operator can for example be used when someone only wants to receive the data from a stock ticker every 5 seconds, without the need to process every value that comes in between.

\paragraph{Debounce} The operator \code{debounce(timespan: Duration)} will only propagate its received values after a certain \code{timespan} has passed without receiving an other value. When a value is received within the \code{timespan}, the previous value is discarded and the same process starts all over again with the newly received value. This operator is most commonly used in text fields within user interfaces, in order to avoid too much keystroke events being generated by a fast typing user. Rather than every keystroke being emitted, this operator will only yield the last keystroke after a particular \code{timespan}. Notice that in some versions of Rx this operator is also referred to as \code{throttleWithTimeout}.

With these operators many situations of potential backpressure can be avoided by eliminating all the elements that do not really matter for a particular application.

\subsubsection{Loss-less operators}
Even though lossy operators will suit many cases of potential backpressure, there are still as many cases left in which all data that is send over a stream needs to be processed. For these kinds op use cases Rx provides so-called loss-less operators. These operators can buffer or group the data and emit collections of data, such that there are at least less elements to deal with.

\paragraph{Buffer} The \code{buffer} operator comes in a couple of different overloads. First of all, the \code{buffer(n: Int): Observable[List[T]]} operator, which receives data and groups it into lists of \code{n} elements. Once a list is filled (its size is \code{n}), it is emitted to downstream. Until then, the operator holds the data it receives. The \code{buffer} operator also comes in another form: \code{buffer(interval: Duration)}, which groups the data it receives within a certain interval into a single list. Finally there is \code{buffer[B](boundary: Observable[B])}, which groups the data it receives between two emissions of \code{boundary} into a single list.

\paragraph{Window} The drawback of a buffer is that it only propagates its received values once the buffer is filled, the boundary \obs fires or the interval is over. All the time in between no elements will be received by the observer or downstream operators. This already becomes clear from the return type: \code{Observable[List[T]]}. In order to accomplish the same behavior but with an \obs rather than a \code{List}, the \code{window} operator is included in Rx, having the same overloads as \code{buffer}. Instead of the list being emitted only once it is completely filled, the inner \obs is emitted as soon as the first element is received and is \emph{completed} once the size, interval or boundary requirement is met.

These operators form a first line of defense against the potential problems that come from having backpressure. For streams where not all elements necessarily need to be processed (for instance the keyboard events on a text field), a lossy operator can be used. For streams where all emitted data is needed, a loss-less operator is the right solution. Besides that, for special occasions lossy and loss-less backpressure operators can be combined in order to create the optimal buffering strategy. This was discussed in some further detail in a conference talk at QCon by Ben Christensen \todo{reference to http://www.infoq.com/presentations/rx-service-architecture (time=29:20)}.

\subsection{Callstack blocking}
Another way of dealing with the problems of backpressure is to block the callstack and with that `park' the thread on which the \obs is running. Despite the fact that this approach goes against the `reactive' and `non-blocking' model of Rx, it can potentially be a viable option if the overproducing \obs runs on a thread that can safely be blocked.

This technique is currently not used in RxJava, but is used in a particular implementation of the \code{zip} operator by Erik Meijer in RxMobile. Here ... \todo{continue with description of Erik's implementation of \code{zip}}

\subsection{Reactive pull}
A much more profound way of dealing with backpressure is to give the \obv some more possibilities to communicate with the upstream \obs. Notice that the only way of communicating upstream is for the \obv to unsubscribe from the \obs. When an unsubscribe happens, the \obs is basically signaled to stop emitting data to the \obv. Besides unsubscribing there is no way in the standard Rx model to communicate upstream.

The Reactive Streams initiative \todo{citation needed} is a collaboration between a number of companies such as Netflix, Pivotal and Typesafe to \textit{provide a standard for asynchronous stream processing with non-blocking backpressure}. They proposed an alternative to the Rx API that gives the \obv more possibilities to manage the number of elements that are emitted by the upstream \obs. RxJava now implements these new concepts by providing a couple of new methods on \obv: \code{request(n: Int)}, which signals to the \obs that it will be able to handle \code{n} new elements and \code{onStart()}, which performs the initial request from the \obv to the \obs. After the initial request is done, the \obs sends the (max) \code{n} elements to the \obv, which receives them in the \code{onNext} method. This is now the place where the \obv can call \code{request} again to receive more data.

This method of requesting the upstream to produce more values is called \textit{reactive pull}. It allows the \obv to \emph{pull} from the data source (\obs) at its own pace. RxJava has set up this way of processing data in such a way that under normal circumstances the stream is just push based. Only when the \obv is experiencing backpressure it will switch to this pull based model. Wrapping it up in this way, the problem of backpressure is not prevented or gone away but is rather moved up the chain of operators to a point where it can be handled better. \todo{citation needed: https://github.com/ReactiveX/RxJava/wiki/Backpressure\#reactive-pull-backpressure-isnt-magic}

With this it limits the number of elements that are in a buffer within certain operators. Using this method, the \code{zip} operator is implemented by using a small buffer for each upstream \obs. It only requests items from one of these sources when there is room for more elements in its buffer. Once all buffers contain at least one element, the operator can remove an element from each buffer, zip these together and push them downstream. After that there is room for at least one extra element in all buffers, hence new requests are sent to the upstream.

Notice that the RxJava wiki \todo{citation needed} points out that this method only works when all streams that are zipped together respond correctly to the \code{request()} method. This is \emph{not} a requirement for the normal \obs, but it is for instances of \obs that are used in operators like \code{zip} that depend on reactive pull. RxJava therefore provides operators such as \code{onBackpressureBuffer} and \code{onBackpressureDrop} that respectively buffer and drop data that cannot be consumed immediately by the downstream \obv.

\todo{Reactive streams?}


















\HRule

\todo{distinction between hot and cold can be made in the section on reactive pull or later}

A general stream can be initiated from different kinds of sources. Streams like a clock or external events such as a mouse move or a key press can only be viewed as \emph{reactive}. It is not possible for a clock to be controlled by a consumer that pulls the next time unit from the stream. Nor is it possible for a keyboard to be regulated by a consumer, such that it can only receive key events when the consumer asks for a next one. These streams are purely reactive and can not be 

Given that reactive programming is push based, it implies that meaning that the producer is in charge and that the consumer has to keep up with the pace in which the producer sends its data. This leads to the general question: ``\emph{What happens when the producer produces more than the consumer can consume?}''. 