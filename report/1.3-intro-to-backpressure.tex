\todo{potentially start the following section on a new page}

\section{Backpressure}
In the previous section we discussed that a reactive collection is exactly the same as every other collection: it obeys the same rules and the same operators (like \code{map} and \code{filter}) can be defined. One difference however is that a reactive collection is push-based, whereas a interactive collection is pull-based. Rather than the consumer being in charge, asking for the next value, here the producer is in charge and \emph{it} decides when to emit a next value. The consumer just has to listen and can only react to the elements emitted by the producer.

A risk that arises from allowing the producer to be in charge is called `\textit{backpressure}'. \todo{reference to literature or website of reactivex.io} This is a concept originally taken from fluid dynamics and occurs when the consumer cannot keep up with the rate in which the producer is producing the data. This gives rise to the problem of what to do with the growing accumulation of unconsumed data.

A classic example of backpressure in reactive systems is the \code{zip} operator, which merges two (or more) streams by using a combiner function whenever both streams have produced an element. In this operator backpressure occurs when one \obs produces twice as fast as the other. The operator cannot keep up with the rate in which the first \obs is producing, since the second \obs is much slower. The most naive implementation for this operator maintains an ever expending buffer of elements emitted by the first \obs to eventually combine them with the data emitted by the slower stream. The major problem with this implementation is that this buffer will have to use an unwieldy amount of system resources.

\subsection{Avoiding backpressure}
One way of dealing with backpressure is to simply avoiding the problem and take proactive measures whenever backpressure is expected happen. In the following we will discuss several ways to reduce the amount of data by using standard operators that are defined on the \obs interface. For this we distinguish two types of operators: lossy and lossless operators. \todo{reference to https://xgrommx.github.io/rx-book/content/getting\_started\_with\_rxjs/creating\_and\_querying\_observable\_sequences/backpressure.html}

\subsubsection{Lossy operators}
One set of operators avoids backpressure in a lossy way, meaning that some of the emitted data will be dropped.

\paragraph{Throttling} The \code{throttle(interval: Duration)} operator only propagates the first element that is received in a particular interval. All other elements are discarded. Once has finished, a new interval starts immediately, in which again the first received element is propagated and all other elements are discarded.

\paragraph{Sample} Rather than propagating the first element and discarding all others, the \code{sample(interval: Duration)} operator is used to discard all elements except for the last one that is received in a certain \code{interval}. This operator can for example be used when someone only wants to receive the data from a stock ticker every 5 seconds, without the need to process every value that comes in between.

\paragraph{Debounce} The operator \code{debounce(timespan: Duration)} will only propagate its received values after a certain \code{timespan} has passed without receiving an other value. When a value is received within the \code{timespan}, the previous value is discarded and the same process starts all over again with the newly received value. This operator is most commonly used in text fields within user interfaces, in order to avoid too much keystroke events being generated by a fast typing user. Rather than every keystroke being emitted, this operator will only yield the last keystroke after a particular \code{timespan}. Notice that in some versions of Rx this operator is also referred to as \code{throttleWithTimeout}.

With these operators many situations of potential backpressure can be avoided by eliminating all the elements that do not really matter for a particular application.

\subsubsection{Loss-less operators}
Even though lossy operators will suit many cases of potential backpressure, there are still as many cases left in which all data that is send over a stream needs to be processed. For these kinds op use cases Rx provides so-called loss-less operators. These operators can buffer or group the data and emit collections of data, such that there are at least less elements to deal with.

\paragraph{Buffer} The \code{buffer} operator comes in a couple of different overloads. First of all, the \code{buffer(n: Int): Observable[List[T]]} operator, which receives data and groups it into lists of \code{n} elements. Once a list is filled (its size is \code{n}), it is emitted to downstream. Until then, the operator holds the data it receives. The \code{buffer} operator also comes in another form: \code{buffer(interval: Duration)}, which groups the data it receives within a certain interval into a single list. Finally there is \code{buffer[B](boundary: Observable[B])}, which groups the data it receives between two emissions of \code{boundary} into a single list.

\paragraph{Window} The drawback of a buffer is that it only propagates its received values once the buffer is filled, the boundary \obs fires or the interval is over. All the time in between no elements will be received by the observer or downstream operators. This already becomes clear from the return type: \code{Observable[List[T]]}. In order to accomplish the same behavior but with an \obs rather than a \code{List}, the \code{window} operator is included in Rx, having the same overloads as \code{buffer}. Instead of the list being emitted only once it is completely filled, the inner \obs is emitted as soon as the first element is received and is \emph{completed} once the size, interval or boundary requirement is met.

These operators form a first line of defense against the potential problems that come from having backpressure. For streams where not all elements necessarily need to be processed (for instance the keyboard events on a text field), a lossy operator can be used. For streams where all emitted data is needed, a loss-less operator is the right solution. Besides that, for special occasions lossy and loss-less backpressure operators can be combined in order to create the optimal buffering strategy. This was discussed in some further detail in a conference talk at QCon by Ben Christensen \todo{reference to http://www.infoq.com/presentations/rx-service-architecture (time=29:20)}.






















\HRule

\todo{distinction between hot and cold can be made in the section on reactive pull or later}

A general stream can be initiated from different kinds of sources. Streams like a clock or external events such as a mouse move or a key press can only be viewed as \emph{reactive}. It is not possible for a clock to be controlled by a consumer that pulls the next time unit from the stream. Nor is it possible for a keyboard to be regulated by a consumer, such that it can only receive key events when the consumer asks for a next one. These streams are purely reactive and can not be 

Given that reactive programming is push based, it implies that meaning that the producer is in charge and that the consumer has to keep up with the pace in which the producer sends its data. This leads to the general question: ``\emph{What happens when the producer produces more than the consumer can consume?}''. 