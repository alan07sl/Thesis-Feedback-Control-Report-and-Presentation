\chapter{Discussion}
In this chapter we summarize and conclude the insights of this thesis, structured by the research questions. Also we propose a number of open challenges as future work.

\section{Conclusion}
\subsection*{In which way can a reactive program already be controlled to prevent overproduction?}
Overproduction occurs in a reactive system whenever the producer (who, according to the definition, is in charge of the emission rate of data) produces more elements than the consumer can handle. In case of a `bursty' system (where the producer emits many elements in a brief period of time and then emits few elements for a long period of time), the consumer can buffer the data and catch up during the `quiet' period. However, in the general case where the emission behavior of a fast producer is unknown, the data cannot be buffered without having the risk of running out of memory.

There are a couple of ways to prevent overproduction that are currently applied to reactive programs. However, these do not work for all kinds of sources that are wrapped in a reactive interface. We distinguish the following kinds of sources that each have distinct behavior that influences what kinds of overflow production can be applied:

\begin{description}
	\item [hot sources] are reactive by definition: they produce their events/elements at their own speed and without any intervention from an observer; these typically include stock tickers and mouse moves.
	\item [cold asynchronous sources] are interactive sources that might take some arbitrary amount of time to produce a next element; these typically include network responses and results from a database query.
	\item [cold synchronous sources] are interactive sources that return their next element immediately, without the need to do any computationally heavy work; these typically include in-memory collections such as a list.
\end{description}

The only solutions that work for a \textit{hot source} are either discarding the data that cannot be processed immediately or grouping it into larger sections and processing it in these groups.

These solutions do also work for the \textit{cold asynchronous sources}, as they are also bound by a certain notion of time. Besides that, the backpressure technique as proposed by Reactive Streams works for these sources as well. This is due to the fact that these sources allow for the consumer to manage the rate at which the producer is allowed to emit its data.

Backpressure also works fine on \textit{cold synchronous sources}, although the best way to control their emission rates is already incorporated on programming language level: callstack blocking. Due to the nature of these streams, the next element can only be emitted once the current element is fully processed. Note that this technique is also naturally used in \textit{hot} and \textit{cold asynchronous sources}, but that this can potentially lead to out-of-memory errors.

\subsection*{How can we implement a \textit{reactive} feedback system that is composed of smaller parts?}
A feedback system can be seen as a mapping from an input stream to an output stream. In terms of control theory, the input stream represents the setpoint, the output stream is the control output that is fed back to be compared with the setpoint's latest value as well as outputted for any other purpose. The same can be said of each individual component of the feedback system: it has an input stream that is transformed into an output stream. This output stream can also be considered the input stream of the next component.

We derived an API for such a component that builds on top of the RxJava library. We also introduced operators for composing these components in both a sequential and parallel way and related these to the well known structure of \textit{Arrow}s. Finally we introduced a set of operators that makes it possible to turn a sequence of components into a feedback system by feeding back the sequence's output stream to its input stream. The resulting API offers a concise way of describing a feedback system in just a couple of lines of code.

\subsection*{How can the overproduction problem be reduced to a feedback control problem?}
We proposed a new solution to the overproduction problem that uses feedback control at its core. While Reactive Stream's backpressure implementation in RxJava moves the overflow control up to a certain operator that can be anywhere in the operator sequence, we chose to move it up to the point where the source is drained into the operator sequence. There we chose to place a buffer and control the number of elements that are being requested from the source. This is done by measuring the \textit{throughput} of the buffer, which is equal to the ratio between how many elements are being pulled out from the buffer and the number of element that were in the buffer during a particular time frame.

With this we have reduced the problem of overproduction to a problem of controlling the size of a buffer. Here the metric (or control output) is the \textit{throughput}, which we bound to be a number between 0.0 and 1.0 (boundaries inclusive). Since the ideal value for the throughput is 1.0 (meaning that all data is consumed directly), we set this as the setpoint of the feedback system that controls the buffer. Using a custom, incremental controller, we transform the tracking error into a new number of elements to be requested from the source.

\subsection*{Can this new solution to overproduction be integrated into an existing API for reactive programming?}
Using our feedback API we were able to construct this feedback system in a `reactive' way and thereby integrate it with the reactive API. Integrating this new solution into the newly created RxMobile API turned out to be as easy as wrapping it into an \code{Observable.create}. 

\section{Future work}
Given the solution to overproduction presented in this thesis, we still see room for improvements and alternative solutions. In this section we will lay out some of the work that is still open for further research. Here we will first focus on open work in the field of overflow protection and then describe some interesting problems in the field of feedback control.

\subsection*{Overproduction}
We already touched on the fact that our solution still uses a fixed constant interval after which the throughput is measured. We acknowledge that an interval is required here, since a continuous measurement does not make sense in the discrete world of computer science. However, it would be interesting to see whether it is possible to make this interval dynamic and control it using another feedback system. For this a mathematical exploration needs to be undertaken to discover what kind of metric would determine the length of such interval, before a feedback system can be derived from it.

Another point of interest is the new RxJava2.0 library\footnote{this completely new rewrite of RxJava came to pass only at the end of writing this thesis}, in which the \obs is pure again and does not have anything to do with backpressure. Instead a \code{Flowable} type is introduced, which wraps an interactive source in a reactive context by applying backpressure. The policy used here is fully abstracted and replaceable with any other policy. It would therefore be interesting to see whether our solution could be fitted and used as just another of these policies. When implemented in this way, it would also be interesting to do a performance analysis and see how this policy compares to any other available policy.

In our solution we have considered the consumer to be a single threaded process which can only consume the elements one by one. This put a restriction on the kinds of sources that could be applied to this solution: due to the fact that we request a certain number of elements, a hot source cannot be applied here. An interesting alternative to look into is to control the number of consumers rather than controlling a buffer size. This is similar to various scheduling and allocation algorithms in distributed computing, but in our opinion this can also be applied to the field of reactive programming. Controlling the number of consumers in this context can either mean a single consumer with a multi threaded process, which can consume multiple elements at a time or literally a variable number of single threaded consumers that work in parallel of each other. We hypothesize that this solution would be suitable not only for cold sources but for hot sources alike.

\subsection*{Feedback control}


\todo{discuss the potentials of future work as listed below}
\begin{itemize}
	\item Backpressure
	\begin{itemize}
		\item Push solution - control number of workers with certain metrics. This will presumably also work with hot streams such as UI events and time
		\begin{itemize}
			\item Queue length
			\item Net queue length change
			\item In/out ratio per time unit
		\end{itemize}
		\item Using RxJava2.x, you can apparently define a `backpressure policy' on the new \code{Flowable} type
		\item \code{interval} in our feedback system; control it using feedback rather than having it as a constant in \code{from}
	\end{itemize}
	\item Feedback control
	\begin{itemize}
		\item It’s basically an algorithm to solve ‘control problems’. How is the problem class defined where feedback control can be used as an easy solution?
		\item It’s difficult to tune PID controllers. (refer to blog) Would it be possible to use ML for this process?
		\item The PID controller originally comes from the field of physics and mechanical/electrical engineering and is considered to be the default controller, given its (mathematical) simplicity and quick response to change. Does this still hold for computer science, since we don’t need/use mathematical models? Or is there an alternative, easier to tune, controller that could be considered as default in computer science? (also take into account that the PID controller makes the assumption of a \textit{continuous} world, whereas computer science presumes a \textit{discrete} world)
		\item We derived a feedback API based on a transformation of $\obs \Rightarrow \obs$. Would it be possible to also do make a similar API by just adding the feedback operator to the \obs API? This would allow for some form of recursion within the stream, allowing for a whole new class of problems to be solved using reactive programming.
	\end{itemize}
\end{itemize}
