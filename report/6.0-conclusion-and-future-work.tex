\chapter{Discussion}
In this chapter we summarize and conclude the insights of this thesis, structured by the research questions. Also we propose a number of open challenges as future work.

\section{Conclusion}
\subsection*{In which way can a reactive program already be controlled to prevent overproduction?}
Overproduction occurs in a reactive system whenever the producer (who, according to the definition, is in charge of the emission rate of data) produces more elements than the consumer can handle. In case of a `bursty' system (where the producer emits many elements in a brief period of time and then emits few elements for a long period of time), the consumer can buffer the data and catch up during the `quiet' period. However, in the general case where the emission behavior of a fast producer is unknown, the data cannot be buffered without having the risk of running out of memory.

There are a couple of ways to prevent overproduction that are currently applied to reactive programs. However, these do not work for all kinds of sources that are wrapped in a reactive interface. We distinguish the following kinds of sources that each have distinct behavior that influences what kinds of overflow production can be applied:

\begin{description}
	\item [hot sources] are reactive by definition: they produce their events/elements at their own speed and without any intervention from an observer; these typically include stock tickers and mouse moves.
	\item [cold asynchronous sources] are interactive sources that might take some arbitrary amount of time to produce a next element; these typically include network responses and results from a database query.
	\item [cold synchronous sources] are interactive sources that return their next element immediately, without the need to do any computationally heavy work; these typically include in-memory collections such as a list.
\end{description}

The only solutions that work for a \textit{hot source} are either discarding the data that cannot be processed immediately or grouping it into larger sections and processing it in these groups.

These solutions do also work for the \textit{cold asynchronous sources}, as they are also bound by a certain notion of time. Besides that, the backpressure technique as proposed by Reactive Streams works for these sources as well. This is due to the fact that these sources allow for the consumer to manage the rate at which the producer is allowed to emit its data.

Backpressure also works fine on \textit{cold synchronous sources}, although the best way to control their emission rates is already incorporated on programming language level: callstack blocking. Due to the nature of these streams, the next element can only be emitted once the current element is fully processed. Note that this technique is also naturally used in \textit{hot} and \textit{cold asynchronous sources}, but that this can potentially lead to out-of-memory errors.

\subsection*{How can we implement a \textit{reactive} feedback system that is composed of smaller parts?}
A feedback system can be seen as a mapping from an input stream to an output stream. In terms of control theory, the input stream represents the setpoint, the output stream is the control output that is fed back to be compared with the setpoint's latest value as well as outputted for any other purpose. The same can be said of each individual component of the feedback system: it has an input stream that is transformed into an output stream. This output stream can also be considered the input stream of the next component.

We derived an API for such a component that builds on top of the RxJava library. We also introduced operators for composing these components in both a sequential and parallel way and related these to the well known structure of \textit{Arrow}s. Finally we introduced a set of operators that makes it possible to turn a sequence of components into a feedback system by feeding back the sequence's output stream to its input stream. The resulting API offers a concise way of describing a feedback system in just a couple of lines of code.

\subsection*{How can the overproduction problem be reduced to a feedback control problem?}
We proposed a new solution to the overproduction problem that uses feedback control at its core. While Reactive Stream's backpressure implementation in RxJava moves the overflow control up to a certain operator that can be anywhere in the operator sequence, we chose to move it up to the point where the source is drained into the operator sequence. There we chose to place a buffer and control the number of elements that are being requested from the source. This is done by measuring the \textit{throughput} of the buffer, which is equal to the ratio between how many elements are being pulled out from the buffer and the number of element that were in the buffer during a particular time frame.

With this we have reduced the problem of overproduction to a problem of controlling the size of a buffer. Here the metric (or control output) is the \textit{throughput}, which we bound to be a number between 0.0 and 1.0 (boundaries inclusive). Since the ideal value for the throughput is 1.0 (meaning that all data is consumed directly), we set this as the setpoint of the feedback system that controls the buffer. Using a custom, incremental controller, we transform the tracking error into a new number of elements to be requested from the source.

%\subsection*{Can this new solution to overproduction be integrated into an existing API for reactive programming?}
%Using our feedback API we were able to construct this feedback system in a `reactive' way and thereby integrate it with the reactive API. Integrating this new solution into the newly created RxMobile API turned out to be as easy as wrapping it into an \code{Observable.create}.

\section{Future work}
Given the solution to overproduction presented in this thesis, we still see room for improvements and alternative solutions. In this section we will lay out some of the work that is still open for further research. Here we will first focus on open work in the field of overflow protection and then describe some interesting problems in the field of feedback control.

\subsection*{Overproduction}
We already touched on the fact that our solution still uses a fixed constant interval after which the throughput is measured. We acknowledge that an interval is required here, since a continuous measurement does not make sense in the discrete world of computer science. However, it would be interesting to see whether it is possible to make this interval dynamic and control it using another feedback system. For this a mathematical exploration needs to be undertaken to discover what kind of metric would determine the length of such interval, before a feedback system can be derived from it.

Another point of interest is the new RxJava2.0 library\footnote{this completely new rewrite of RxJava came to pass only at the end of writing this thesis}, in which the \obs is pure again and does not have anything to do with backpressure. Instead a \code{Flowable} type is introduced, which wraps an interactive source in a reactive context by applying backpressure. The policy used here is fully abstracted and replaceable with any other policy. It would therefore be interesting to see whether our solution could be fitted and used as just another of these policies. When implemented in this way, it would also be interesting to do a performance analysis and see how this policy compares to any other available policy.

In our solution we have considered the consumer to be a single threaded process which can only consume the elements one by one. This put a restriction on the kinds of sources that could be applied to this solution: due to the fact that we request a certain number of elements, a hot source cannot be applied here. An interesting alternative to look into is to control the number of consumers rather than controlling a buffer size. This is similar to various scheduling and allocation algorithms in distributed computing, but in our opinion this can also be applied to the field of reactive programming. Controlling the number of consumers in this context can either mean a single consumer with a multi threaded process, which can consume multiple elements at a time or literally a variable number of single threaded consumers that work in parallel of each other. We hypothesize that this solution would be suitable not only for cold sources but for hot sources alike.

\subsection*{Feedback control}
While researching the field of feedback control, it was very surprising to see that this technique was hardly ever used in computer science. Despite it being well known and often used in all kinds of fields of science, it was hard to find any related work in our field. A possible explanation for this might be the highly involved mathematical notions that formally describe a feedback system, which are hard or impossible to be applied to computer science. More work needs to be done to formalize this technique for this field. A particular distinction to be focused on is the continuous nature of a mathematical feedback system and discrete nature that is required in computer science.

On the same note, feedback control provides a simple but powerful solution to a wide range of problems. However, the problems we have seen during our research in this field all look alike. This makes us hypothesize that a formal classification can be made of problems that can be solved using feedback control. Just like some problems can be classified as $P$, $NP$ or $NPC$, we hypothesize that a similar thing can be done for a class of problems $FC$ that can be solved using feedback control. Metrics about complexity of runtime and space would be equally interesting to formalize for this class, such that comparisons can be made of the performance of different feedback systems.

Another interesting part of control theory that requires more research is based on the controller. For feedback systems in physics and engineering, who all assume a \textit{continuous} world in which is feedback system is ran, the PID controller is the standard controller to use, due to its simplicity en accuracy. However, this controller is not particularly well-suited for systems that run in a \textit{discrete} world, as is the case in computer science. We hypothesize that a similar, but discrete, controller should exist for these systems.
