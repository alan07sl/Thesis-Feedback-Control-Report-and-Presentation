\section{Related work}
One of the few libraries we found is described by Philip Janert in his book ``\textit{Feedback Control for Computer Systems}'' \cite{janert2013-feedback}. Janert presents a small framework for simulating feedback loops with the purpose of being a teaching tool that makes it simple and transparent to demonstrate the algorithms presented in several case studies and to encourage experimentation. He explicitly states that little emphasis was placed on elegant implementations or time efficiency and that this framework is not meant to be used in production software. What distinguishes his framework from other simulation frameworks for control systems (for example MatLab \cite{Matlab-Feedback}), however, is the way that the components that make up a feedback loop are implemented. As discussed before, most feedback systems in physics and engineering are described in terms of complex mathematics, using transfer functions and Laplace transformations, that operate in the frequency domain. Janert's API, however, allows algorithms to be implemented in the time domain, which is a more natural representation to software developers and people that are not familiar to the mathematics based approach.

One of the central aspects of Janert's framework is the \code{Component} class which contains two methods with the following signatures: \code{def work(u: Double): Double}, which encapsulates the dynamic function of a component, called once every feedback cycle and \code{def monitoring: String}, which is just a convenience function and allows for a uniform approach to logging. All components (controlled systems, controllers and more advanced building blocks like actuators and filters) are just subclasses of \code{Component} that implement these two methods. The feedback system is then simulated using a loop that iterates over time stamps and which calls the \code{work} method on the next \code{Component} with the result of calling the \code{work} method of the previous \code{Component}. Finally at the end of each loop cycle the result is printed to the console using the \code{monitor} method of the \code{Component} that represents the system under control.

As pointed out by Janert, this framework does well for simulation but is not really useful for production software. One concern with this framework is that it performs a feedback cycle with regular intervals between each other. However, one can easily imagine a controlled system which produces a control output very irregularly. In that case the feedback cycle has to respond to the emission of a new data point rather than asking the controlled system for its next input. Another concern related to this is the ability to handle concurrency appropriately. A component in the feedback loop might perform some kind of timing related work that requires running on a different thread or thread pool. Finally we should note that the subclasses of \code{Component} have to use mutable state if they want to store any data. Think of the Integral Controller, which has to store its current sum. Mutable state is something that computer science has come to terms with as not being so practical in some cases as we once thought it would be. Especially when introducing concurrency, mutable state is something you want to avoid at all cost!
