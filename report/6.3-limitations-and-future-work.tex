\section{Limitations and future work}
The proposed solution for controlling overflow does have its limitations. First of all, we were not able to compare our approach with the backpressure solution that is offered by Reactive Streams in implementations such as RxJava's reactive pull in an experimental way. Because we required a \emph{purely reactive} API, we were not able to implement our solution in RxJava directly; otherwise our solution would have implicitly relied on the reactive pull implementation. Instead we decided to use the RxMobile reference implementation that was recently written by Erik Meijer. This implementation is purely reactive, does not take backpressure, reactive pull or any other measures for controlling overflow into account. It instead makes the assumption that the consumer is responsible for making sure it can handle as much data as is served to it, which follows from the definition of a reactive program by Benveniste and Berry. We fully acknowledge that RxMobile is a \emph{reference implementation}, which is not optimized for performance by any means. This is of course in contrast to RxJava, which has performance as one of its main priorities.

Comparing our approach of controlling overflow with RxJava's reactive pull implementation in an experimental way would require us to account for the performance optimizations in RxJava and the lack thereof in RxMobile in our measurements. Currently measuring the performance of both solutions to controlling overflow in any way would be greatly affected by this optimization factor and would therefore give RxJava an unfair advantage over RxMobile. Performing useful experiments to compare both implementations requires us to have equal (or at least similar in terms of performance optimization) implementations on the rest of the API.

Another limitation of our overflow solution is that it only provides an alternative for RxJava's \code{onBackpressureBuffer}. Each element that is not processed immediately will be buffered for later processing. The alternative to this would be an overflow solution that is equal to RxJava's \code{onBackpressureDrop} operator, which discards all data that cannot be processed immediately. We think that, given our current solution to \code{onBackpressureBuffer}, it would not be very hard to modify this and implement a similar solution for \code{onBackpressureDrop}. Instead of keeping the unprocessed data in a buffer, we would have to clear the buffer after each feedback cycle. This would, however, also require a modification to the metric we use in the feedback loop, as this currently takes into account the size of the buffer. This also gives rise to a new mathematical analysis of this metric.

A further generalization of these different strategies to backpressure is given in the new and upcoming RxJava2.0, where the user is able to, besides using the \code{onBackpressureDrop} and \code{onBackpressureBuffer}, implement its own strategy to backpressure. This is a great improvement, which gives the user much more freedom. It would be interesting to investigate a similar generalization in our overflow solution and to so what is still required to make this change.

Besides that, further research is needed to the performance of the controller in our approach of overflow protection. We currently have a very simple controller that changes the requested number of elements by at most one per feedback cycle. Further research is needed to make this controller more responsive and to make better decisions of how many elements are being requested per feedback cycle.

Related to control theory and feedback control we observed earlier in this report that its use is widespread in all areas of science and engineering, except for the field of computer science. Despite having this fairly simple technique to our disposal, we as computer scientists still stick to more complex algorithms. We hope the contribution of our API will spark some interest in this area. We see great opportunities for this technique in many parts of computer science that have to deal with control, such as cloud computing, network control and machine learning.
